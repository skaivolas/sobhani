---
title: Grammar Construction in the Minimalist Program — References
layout: page
---

[Back](jherring-6)

# <span id="anchor-122"></span>References

Abels, Klaus. 2003. “Successive Cyclicity, Anti-Locality, and Adposition
Stranding.” PhD thesis, University of Connecticut.

Adger, David. 2003. *Core Syntax: A Minimalist Approach*. Oxford
University Press.

Aissen, Judith, and David Perlmutter. 1976. “Clause Reduction in
Spanish.” In *BLS 2. Proceedings of the 2nd Annual Meeting of the BLS*,
edited by H. Thompson, 1–30. Linguistic Society of America.

Baker, Mark. 1988. *Incorporation: A Theory of Grammatical Function
Changing*. University of Chicago Press.

Baker, Mark. 2003. “Syntax.” In *The Handbook of Linguistics.*, edited
by Mark Aronoff and Janie Rees-Miller. Wiley-Blackwell.

Baker, Mark. 2008. *The Syntax of Agreement and Concord*. Edited by Mark
Aronoff and Janie Rees-Miller. Cambridge University Press.

Baker, Mark, Kyle Johnson, and Ian Roberts. 1989. “Passive Arguments
Raised.” *Linguistic Inquiry *20 (2). MIT: 219–51.

Béjar, Susana, and Milan Rezac. 2003. “Person Licensing and the
Derivation of PCC Effects.” In *Romance Linguistics: Theory and
Acquisition*, edited by Ana Teresa Pérez-Leroux and Yves Roberge, 49–62.
Current Issues in Linguistic Theory. John Benjamins.

Bhatt, Rajesh. 2005. “Long-Distance Agreement in Hindi-Urdu.” *Natural
Language and Linguistic Theory *23: 757–807.

Bhatt, Rajesh, and Roumyana Pancheva. 2006. “Implicit Arguments.” In
*The Blackwell Companion to Syntax*. Blackwell.

Bobaljik, Jonathan. 2002. “Realizing Germanic Inflection: Why Morphology
Does Not Drive Syntax.” *Journal of Comparative Germanic Linguistics *6:
129–67.

Bobaljik, Jonathan, and Samuel Brown. 1997. “Interarboreal Operations:
Head Movement and the Extension Requirement.” *Linguistic Inquiry*, no.
28: 345–56.

Bobaljik, Jonathan, and Idan Landau. 2009. “Icelandic Control Is Not
a-Movement: The Case from Case.” *Linguistic Inquiry*, no. 40: 269–80.

Bobaljik, Jonathan, and Susi Wurmbrand. 2005. “The Domain of Agreement.”
*Natural Language and Linguistic Theory *23: 809–65.

Boeckx, Cedric. 2008a. *Aspects of the Theory of Agreement*. Routledge
Leading Linguists. Routledge.

Boeckx, Cedric. 2008b. *Bare Syntax*. Oxford University Press.

Boeckx, Cedric. 2008c. *Understanding Minimalist Syntax: Lessons from
Locality in Long-Distance Dependencies*. Wiley.

Boeckx, Cedric, and Kleanthes Grohmann. 2007. “Remark: Putting Phases in
Perspective.”

*Syntax*, no. 2. Blackwell Publishing Ltd.: 204–22.

Boeckx, Cedric, Norbert Hornstein, and Jairo Nunes. 2010. *Control as
Movement*. Cambridge University Press.

Boskovic, Jelko, and Jairo Nunes. 2007. “The Copy Theory of Movement: A
View from PF.” In *The Copy Theory of Movement*, edited by Norbert
Corver and Jairo Nunes. Linguistik Aktuell/Lingusitics Today. John
Benjamins Publishing Company.

Bouchard, Denis. 1984. *On the Content of Empty Categories*. Studies in
Generative Grammar. Foris.

Brannigan, Phil. 2010. *Provocative Syntax*. Linguistic Inquiry
Monographs. MIT.

Bray, T. 2014. “The JavaScript Object Notation (JSON) Data Interchange
Format.” RFC 7159. Internet Engineering Task Force.
<https://tools.ietf.org/html/rfc7159>.

Bresnan, Joan. 1982. “Control and Complementation.” *Linguistic Inquiry
*13 (3): 343–434.

Bresnan, Joan. 2001. *Lexical-Functional Grammar*. Blackwell Publishers
Ltd.

Chandra, Pritha. 2007. “\[Dis\]agree: Movement and Agreement
Reconsidered.” PhD thesis, University of Maryland.

Chomsky, Noam. 1957. *Syntactic Structures*. The Hague: Mouton.

Chomsky, Noam. 1981. *Lectures on Government and Binding: The Pisa
Lectures*. Walter de Gruyter.

Chomsky, Noam. 1986a. *Barriers*. Linguistic Inquiry Monographs. MIT
Press.

Chomsky, Noam. 1986b. *Knowledge of Language: Its Nature, Origin and
Use*. Praeger.

Chomsky, Noam. 1991. “Some Note on Economy of Derivation and
Representation.” In *Principles and Parameters in Comparative Grammar*,
edited by Robert Freidin, 417–54. The MIT Press.

Chomsky, Noam. 1993. “A Minimalist Program for Linguistic Theory.” In
*The View from Building 20: Essays in Linguistics in Honor of Sylvain
Bromberger*, edited by Ken Hale and Samuel J. Keyser. The MIT Press.

Chomsky, Noam. 1995. *The Minimalist Program*. MIT Press.

Chomsky, Noam. 2000. “Minimalist Inquiries: The Framework.” In *Step by
Step: Essays on Minimalist Syntax in Honor of Howard Lasnik*, edited by
Roger Martin and Juan Uriagereka. MIT Press.

Chomsky, Noam. 2001. “Derivation by Phase.” In *Ken Hale: A Life in
Language*, edited by Michael Kenstowicz. MIT Press.

Chomsky, Noam. 2005. “Three Factors in Language Design.” *Linguistic
Inquiry *36 (1).

Chomsky, Noam. 2008. “On Phases.” In *Foundational Issues in Linguistic
Theory: Essays in Honor of Jean-Roger Vergnaud*, edited by Robert
Freidin, Carlos P. Otero, and Maria Luisa Zubizarreta. The MIT Press.

Chomsky, Noam, and Howard Lasnik. 1993. “The Theory of Principles and
Parameters.” In *Syntax: An International Handbook of Contemporary
Research*, edited by J. Stechow, A. Jacobs, W. Sternefeld, and T.
Vennemann. De Gruyter.

Citko, Barbara. 2014. *Phase Theory: An Introduction*. Research Surveys
in Linguistics. Cambridge University Press.

Clements, G. N. 1985. “The Geometry of Phonological Features.” In
*Phonology Yearbook 2*, edited by Collin Ewen and John Anderson, 225–52.
Cambridge University Press.

Collins, Chris, and Edward Stabler. 2016. “A Formalization of Minimalist
Syntax.” *Syntax *19 (1): 43–78.

Copestake, Ann. 2002. *Implementing Typed Feature Structure Grammars*.
CSLI.

Copestake, Ann, and Dan Flickinger. 2000. “An Open-Source Grammar
Development Environment and Broad-Coverage English Grammar Using HPSG.”
In *Proceedings of the Second Conference on Language Resources and
Evaluation (LREC-2000)*. Athens.

Culicover, Peter W., and Ray Jackendoff, eds. 2005. *Simpler Syntax*.
Oxford University Press.

den Dikken, Marcel. 2014. “On Feature Interpretability and Inheritance.”
In *Minimalism and Beyond: Radicalizing the Interfaces*, edited by Peter
Kosta, Steven Franks, Teodora Radeva-Bork, and Lilia Schürcks. John
Benjamins Publishing Company.

Epstein, Samuel David, and T. Daniel Seely. 2006. *Derivations in
Minimalism*. Cambridge University Press.

Epstein, Samuel, and Norbert Hornstein. 1999. “Working Minimalism:
Introduction.” In

*Working Minimalism*. The MIT Press.

Felser, Claudia. 2004. “Wh-Copying, Phases, and Successive Cyclicity.”
*Lingua *114 (5). MIT Press: 543–74.

Flickinger, Dan, Emily M. Bender, and Stephan Oepen. 2014. “Towards an
Encyclopedia of Compositional Semantics: Documenting the Interface of
the English Resource Grammar.” In *Proceedings of the Ninth
International Conference on Language Resources and Evaluation (LREC14)*,
edited by Nicoletta Calzolari, Khalid Choukri, Thierry Declerck, Hrafn
Loftsson, Bente Maegaard, Joseph Mariani, Asuncion Moreno, Jan Odijk,
and Stelios Piperidis, 875–81. Reykjavik, Iceland: European Language
Resources Association (ELRA).

Fong, Sandiwey, and Jason Ginsburg. in preparation. *The Minimalist
Machine*. Research Monograph.

Fox, Danny, and David Pesetsky. 2005. “Cyclic Linearization of Syntactic
Structure.” *Theo- retical Linguistics *31. MIT Press: 1–46.

Franks, Steven, and James Lavine. 2006. “Case and Word Order in
Lithuanian.” *Journal of Linguistics *42: 239–88.

Fukui, Naoki. 1993. “A Note on Improper Movement.” *The Linguistic
Review *10 (2): 111–26.

Funakoshi, Kenji. 2013. “Syntactic Head Movement and Its Consequences.”
PhD thesis, Maryland.

Gallego, Angel J. 2010. *Phase Theory*. John Benjamins Publishing
Company.

Haegeman, Liliane. 1994. *Introduction to Government and Binding
Theory*. Blackwell Publishers Ltd.

Harkema, Hendrik. 2001. “Parsing Minimalist Languages.” PhD thesis,
University of California at Los Angeles.

Harris, Zellig. 1951. *Methods in Structural Linguistics*. University of
Chicago Press.

Heim, Irene, and Angelika Kratzer. 1998. *Semantics in Generative
Grammar*. Wiley- Blackwell.

Herring, Joshua. 2009. “Call by Reference Syntax: Toward a Pointer
Implementation of (Re)merge.”

Hiraiwa, Ken. 2005. “Dimensions of Symmetry in Syntax: Agreement and
Clausal Architec- ture.” PhD thesis, MIT.

Holmberg, Anders. 1986. “Word Order and Syntactic Features in the
Scandinavian Languages and English.” PhD thesis, University of
Stockholm.

Hopcroft, John E., Rajeev Motwani, and Jeffrey D. Ullman. 2001.
*Introduction to Automata Theory, Languages, and Computation*. 2nd ed.
Pearson.

Hornstein, Norbert. 1999. “Movement and Control.” *Linguistic Inquiry
*30 (1).

Hornstein, Norbert. 2000. *Move\! A Minimalist Theory of Construal*.
Wiley.

Hornstein, Norbert, and William Idsardi. 2014. “A Program for the
Minimalist Program.” In

*Radicalizing the Interfaces*. John Benjamins Publishing Company.

Hornstein, Norbert, and Maria Polinsky. 2010. “Control as Movement:
Across Languages and Constructions.” In *Movement Theory of Control*.
Linguistik Aktuell. John Benjamins.

Hornstein, Norbert, Jairo Nunes, and Kleanthes K. Grohman. 2005.
*Understanding Minimal- ism*. Cambridge University Press.

Joshi, Aravind, and Yves Schabes. 1997. “Tree Adjoining Grammars.” In
*Handbook of Formal Languages Vol 3: Beyond Words*, edited by Grzegorz
Rozenberg and Arto Salomaa. Vol. 3. Springer.

Kayne, Richard S. 1994. *The Antisymmetry of Syntax*. Linguistic Inquiry
Monographs 25. The MIT Press.

Landau, Idan. 2000. *Elements of Control: Structure and Meaning in
Infinitival Constructions*. Kluwer.

Landau, Idan. 2003. “Movement Out of Control.” *Lingusitic Inquiry *34
(3). MIT: 471–98.

Landau, Idan. 2004. “The Scale of Finiteness and the Calculus of
Control.” *Natural Language and Linguistic Theory *22 (4): 811–77.

Landau, Idan. 2006. “Severing the Distribution of PRO from Case.”
*Syntax *9 (2): 153–70.

Landau, Idan. 2008. “Two Routes of Control: Evidence from Case
Transmission in Russian.” *Natural Language and Linguistic Theory *26
(4). Springer: 877–924.

Landau, Idan. 2015. *A Two-Tiered Theory of Control*. Linguistics
Inquiry Monographs. MIT. Lasnik, Howard. 1999. *Minimalist Analysis*.
Blackwell.

Lasnik, Howard, and Mamoru Saito. 1991. “On the Subject of Infinitives.”
In *Papers from the 27th Regional Meeting of CLS*, 324–43. Chicago, IL:
CLS.

Lightfoot, David. 1979. *The Principles of Diachronic Syntax*. Cambridge
Studies in Linguistics. Cambridge University Press.

Matthew, Rosmin. 2015. *Head Movement in Syntax*. John Benjamins.

McGinnis, Martha. 2005. “On Markedness Asymmetries in Person and
Number.” *Language *81 (3): 699–718.

Melcuk, Igor, and Nikolai V. Pertsov. 1987. *Surface Syntax of English:
A Formal Model Within the Meaning-Text Framework*. John Benjamins
Publishing Company.

Merchant, Jason. 2011. “Aleut Case Matters.” In *Pragmatics and
Autolexical Grammar: In Honor of Jerry Sadock*, edited by Etsuyo Yuasa
Yuasa, Tista Bagchi, and Katharine P. Beals, 382–411. John Benjamins.

Müller, Gereon, and Wolfgang Sternefeld. 1993. “Improper Movement and
Unambiguous Binding.” *Linguistic Inquiry *24 (3): 461–507.

Narita, Hiroki. 2011. “Phasing in Full Interpretation.” PhD thesis,
Harvard.

Nevins, Andrew. 2007. “The Representation of Third Person and Its
Consequences for Person-Case Effects.” *Natural Language and Linguistic
Theory *25 (2): 273–313.

Nunes, Jairo. 2004. *Linearization of Chains and Sideward Movement*. MIT
Press.

Okasaki, Chris. 1999. *Purely Functional Data Structures*. Cambridge
University Press.

Ouali, Hamid. 2008. “On c-to-T Phi-Feature Transfer: The Nature of
Agreement and Anti- Agree- Ment in Berber.” In *Agreement Restrictions*,
edited by Roberta D’Alessandro, Susann Fischer, and Gunnar Hrafn
Hrafnbjargarson. Walter de Gruyter.

Pesetsky, David, and Esther Torrego. 2007. “The Syntax of Valuation and
the Interpretability of Features.” In *Phrasal and Clausal
Architecture*, edited by Wendy Wilkins Simin Karmini Vida Samiian,
355–426. John Benjamins.

Pollard, Carl, and Ivan Sag. 1994. *Head-Driven Phrase Structure
Grammar*. CSLI.

Pollock, Jean-Yves. 1989. “Verb Movement, Universal Grammar and the
Structure of IP.”

*Linguistic Inquiry *20. MIT Press: 365–425.

Postal, Paul. 1974. *On Raising: An Inquiry into One Rule of English
Grammar and Its Theoretical Implications*. Current Studies in
Linguistics. MIT.

Preminger, Omer. 2014. *Agreement and Its Failures*. Vol. 68. Linguistic
Inquiry Monographs. MIT.

Richards, Marc. 2010. “Deriving the Edge: What’s in a Phase.” *Syntax*,
no. 14: 74–95.

Rizzi, Luigi. 1978. “A Restructuring Rule in Italian Syntax.” In *Recent
Transformational Studies in European Languages*, edited by Samuel Jay
Keyser, 113–58. MIT Press.

Roberts, Ian. 2011. “Head Movement and the Minimalist Program.” In *The
Oxford Handbook of Linguistic Minimalism*, edited by Cedric Boeckx.
Oxford University Press.

Sag, Ivan, Tom Wasow, and Emily Bender. 2003. *Syntactic Theory: A
Formal Introduction*. University of Chicago Press.

Sedgewick, Robert, and Kevin Wayne. 2011. *Algorithms*. 4th ed.
Addison-Wesley Professional.

Sigurdsson, Halldor Armand. 2008. “The Case of PRO.” *Natural Language
and Linguistic Theory*. Springer.

Stabler, Edward. 1997. “Derivational Minimalism.” In *Logical Aspects of
Computational Linguistics*, edited by Christian Retore, 68–95. Springer.

Stabler, Edward. 2001. “Minimalist Grammars and Recognition.” In
*Linguistic Form and Its Computa- tion*. CSLI.

Stabler, Edward. 2011. “Computational Perspectives on Minimalism.” In
*Oxford Handbook of Linguistic Minimalism*, edited by Cedrick Boeckx,
617–42. Oxford University Press.

Strachey, Christopher, and Christopher P. Wadsworth. 1972.
*Continuations: A Mathematical Semantics for Handling Full Jumps*.
Technical Monograph: Oxford University Computing Laboratory.

Taraldsen, Knut. 1995. “On Agreement and Nominative Objects in
Icelandic.” In *Studies in Comparative Germanic Syntax*, edited by
Hubert Haider, Susan Olsen, and Sten Vikner. Kluwer.

Thrainsson, Haldur. 1986. “On Auxiliaries, AUX and VPs in Icelandic.” In
*Topics in Scandinavian Syntax*, edited by L. Hellan and K. K.
Christensen, 235–66. Dordrecht.

Travis, Lisa. 1984. “Parameters and Effects of Word Order Variation.”
PhD thesis, MIT. Urk, Coppe van. 2013. “Visser’s Generalization: The
Syntax of Control and the Passive.”

*Linguistic Inquiry *44 (1): 168–78.

Vikner, Sten. 2005. “Object Shift.” In *The Blackwell Companion to
Syntax*, edited by Martien Evaert and Henrik van Riemsdijk. Vol. 3.
Blackwell Publishing Ltd.

Wurmbrand, Susi. 2001. *Infinitives: Restructuring and Clause
Structure*. Vol. 55. Studies in Generative Grammar. Mouton de Gruyter.

Wurmbrand, Susi. 2015. “Restructuring Cross-Linguistically.” In *NELS
45. Proceedings of the North Easter Linguistic Society Annual Meeting
45*, edited by Thuy Bui and Deniz Özyıldız, 227–40. University of
Massachusetts Amherst: GLSA.

Zeijlstra, Hedde. 2012. “There Is Only One Way to Agree.” *The
Lingusitic Review *29 (3). De Gruyter: 491–539.

# <span id="anchor-123"></span>Appendices

## <span id="anchor-124"></span>Appendix A — Visser’s Generalization in Detail: A Derivational Example

This section repeats the system derivation of the Movement Theory of
Control \[@horn- stein:polinsky:10\]treatment of Visser’s Generalization
from Chapter 5 in greater detail for readers with a special interest in
the operation of the grammar toolkit. The reader is expected to be
familiar with arguments made in chapters 4 and 5 — especially the
overview of the MTC analysis of Visser’s Generalization, as discussion
in that section will be relevant to understanding where this derivation
(potentially) goes wrong.

It should be emphasized again that the interpretive component is not a
part of this project; it is left for future implementation by qualified
semanticists. This commits this system to a clean separation between
**SpellOut **and **Transfer**, at least for now — with **SpellOut
**being a cyclic process that assembles the input to PF and **Transfer
**a post-derivational process that assembles the input to LF. The
assumption is that the interpretive process consumes the completed tree
as input.

### <span id="anchor-125"></span>THE MOVEMENT THEORY OF CONTROL

This subsection repeats and augments the text from chapter 5 associated
with the MTC derivation of *John*<sub>i </sub>*promised Mary John*<sub>i
</sub>*to win *to give a clearer illustration of how the system
operates. Items used are taken from the lexicon given in Appendix C.
Output has been somewhat simplified from the actual system output for
reasons of space and formatting requirements.

One point of likely controversy in this derivation and others that (the
default version of) this system performs will involve the ordering of
**head incorporation**, which frequently comes *before *the ***merge
***of the incorporating head’s arguments. It was argued in chapter 4
that this move is conceptually more sound while yielding the same
ultimate output, and the derivation below illustrates why this is so. In
effect, ***head incorporation ***is a way for a system to allow a
construct to accept more than two arguments while maintaining a binary
branching representation.

The lexical array is:

John, promise, to-P, Mary, to<sub>inf</sub>, win, v<sub>trans</sub>,
v<sub>ditrans</sub>, T-past, C

grouped into subarrays as follows:

\{\{win, v<sub>intrans</sub>\}, \{John\}, \{to-P, Mary\}, \{to<sub>inf</sub>\},
\{promise, v<sub>ditrans</sub>\}, \{T-past, C\}\}

1)  Create an instance of a ***derivation ***class and pass this
    ***lexical array ***to it, along with the default ***strategy***.
2)  The ***derivation ***determines it is in the **start **state based
    on the fact that it has a populated ***lexical array ***and an empty
    ***history ***array.

***\{***

*****l******exical\_array: \[ \[\{"v\_intrans"\}, \{"win"\}\],
\[\{"John"\}\],***

***\[\{"to\_inf"\}\],***

***\[\{"to-P"\}, \{"Mary"\}\],***

***\[\{"promise"\}, \{"v\_ditrans"\}\],***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[\], active\_stages: \[\], state: "start"***

***\}***

1)  Because it is in the “start” state, it creates a ***stage ***from
    the first item in its ***lexical array ***and makes this the active
    stage. The ***stage ***likewise determines it is in a

**start **state based on the fact that it has a populated ***lexical
array ***and an empty

*****w******orkspace***:

***DERIVATION***

***\{***

*****l******exical\_array: \[ \[\{"John"\}\],***

***\[\{"to\_inf"\}\],***

***\[\{"to-P"\}, \{"Mary"\}\],***

***\[\{"promise"\}, \{"v\_ditrans"\}\],***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[\<stage\_1\>\], active\_stages: \[\<stage\_1\>\],
state: "active", convergent: false***

***\}***

***STAGE\_1***

***\{***

*****l******exical\_array: \[\{"v\_intrans"\}, \{"win"\}\], workspace:
\[\],***

*****s******tate: "designate", convergent: false***

***\}***

***ASSEMBLED TREES***

*****n******one***

1)  The ***derivation ***now passes the active stage to its ***strategy
    ***function (the system default). Recall from chapter 4 that a
    ***strategy ***is a function that takes a ***stage ***as input and
    returns a new ***stage ***as output. Based on this ***stage***, the
    ***derivation ***then decides whether it is ***convergent ***or
    ***divergent***, and if ***divergent ***whether pathologically so.
    If is it ***convergent ***or pathologically ***divergent***, it will
    halt. Otherwise, it places the new ***stage ***on the ***history
    ***array. In the general case, it will also replace the old active
    ***stage ***with this new ***stage***. However, this is not always
    the case. Sometimes it will retain a pointer to a previous
    ***stage***. Examples of this follow, but the basic idea is that it
    does this when an individual stage has completed but does not
    represent a completion of the derivation (i.e. the information it
    holds will have to be reintegrated into the derivation at a later
    stage). In this particular case, the ***strategy ***determines that
    the ***stage ***should choose an active item. In the default case,
    this is done with a heuristic based on which of the items in the
    ***lexical array ***can **select **which other items and prefers
    those. In this array, ***v\_intrans ***can select ***win ***but not
    the other way around, so ***v\_intrans ***is picked first.

***DERIVATION***

***\{***

*****l******exical\_array: \[ \[\{"John"\}\],***

***\[\{"to\_inf"\}\],***

***\[\{"to-P"\}, \{"Mary"\}\],***

***\[\{"promise"\}, \{"v\_ditrans"\}\],***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***\<stage\_2\>\], active\_stages: \[\<stage\_2\>\], state: "active",
convergent: false***

***\}***

***STAGE\_2***

***\{***

*****l******exical\_array: \[\{"win"\}\],***

*****w******orkspace: \[\{"v\_intrans"\}\], state: "probe", convergent:
false***

***\}***

***ASSEMBLED TREES***

*****n******one***

1)  Since ***stage\_2 ***is in an **active **state, it gets passed again
    to the ***strategy ***which returns ***stage\_3***. Where
    ***stage\_1 ***represented the output of the **Activate **part of
    the cycle outlined in chapter 4, ***stage\_2 ***and ***stage\_3
    ***are in the **Perform **cycle. ***stage\_3 ***is specifically in
    the **Probe **part of the cycle. Because the default ***strategy
    ***enforces the **merge-over-move **constraint, the active item
    ***v\_intrans ***first ***probe***s in ***stage\_3***’s ***lexical
    array***\[ˆnochoice\]. ***v\_intrans ***has a **selector **feature
    (***=V\[\]***) that matches a **selectee **feature on ***win
    ***(***cV\[win\]***), as the reader may verify by consulting the
    ***lexicon***. Therefore, ***stage\_3 ***has **select**ed ***win
    ***into the ***workspace***, marking it as syntactically active.

***DERIVATION***

***\{***

*****l******exical\_array: \[ \[\{"John"\}\],***

***\[\{"to\_inf"\}\],***

***\[\{"to-P"\}, \{"Mary"\}\],***

***\[\{"promise"\}, \{"v\_ditrans"\}\],***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***\<stage\_2\>,***

***\<stage\_3\>\], active\_stages: \[\<stage\_3\>\], state: "active",
convergent: false***

***\}***

***STAGE\_3***

***\{***

*****l******exical\_array: \[\],***

*****w******orkspace: \[\{"v\_intrans"\}, \{"win"\}\], state: "react",***

*****c******onvergent: false***

***\}***

***ASSEMBLED TREES***

*****n******one***

1)  Since the features involved in the selection in ***stage\_3 ***were
    **select **features, and ***merge ***is a side-effect of
    ***select***, the ***strategy ***produces a ***stage\_4 ***in which
    the two active items in the ***workspace ***have ***merge***d. The
    ***ASSEMBLED TREES ***section shows the ***syntactic object ***for
    ***v\_intrans ***with a single member in its ***constituents
    ***array, indicating that ***win ***is now its ***complement***.
    ***win ***here should be understood as a pointer to another
    ***syntactic object ***representing ***win***, which of course has
    no items in its constituents array.

***DERIVATION***

***\{***

*****l******exical\_array: \[ \[\{"John"\}\],***

***\[\{"to\_inf"\}\],***

***\[\{"to-P"\}, \{"Mary"\}\],***

***\[\{"promise"\}, \{"v\_ditrans"\}\],***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***\<stage\_2\>,***

***\<stage\_3\>,***

***\<stage\_4\>\], active\_stages: \[\<stage\_4\>\], state: "active",
convergent: false***

***\}***

***STAGE\_4***

***\{***

*****l******exical\_array: \[\],***

*****w******orkspace: \[\{"v\_intrans", "win"\}\], state: "react",***

*****c******onvergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "v\_intrans", syn: \[***

***"cv\[intrans\]",***

***"=V\[\]",***

***"=D\[\]\],***

*****s******em: "",***

*****p******hon: "", constituents: \["win"\]***

***\}***

![](Pictures/1001BCCF0000044700000949FD4757B602F62172.svgPictures/100002010000001F000000437200C7C358C56F9A.png)

1)  *****p******robe***s happen in response to ***merge***, first from
    the **select**or and then, in the opposite direction, from the
    **select**ee. In the interest of space, these steps have been
    collapsed here (since there are no relevant ***probe***s on ***win
    ***anyway)\[ˆmorestages\].

***DERIVATION***

***\{***

*****l******exical\_array: \[ \[\{"John"\}\],***

***\[\{"to\_inf"\}\],***

***\[\{"to-P"\}, \{"Mary"\}\],***

***\[\{"promise"\}, \{"v\_ditrans"\}\],***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***\<stage\_2\>,***

***\<stage\_3\>,***

***\<stage\_4\>,***

***\<stage\_5\>\], active\_stages: \[\<stage\_5\>\], state: "active",
convergent: false***

***\}***

***STAGE\_5***

***\{***

*****l******exical\_array: \[\],***

*****w******orkspace: \[\{"v\_intrans", "win"\}\], state: "react",***

*****c******onvergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "v\_intrans", syn: \[***

***"cv\[intrans\]",***

***"=V\[win\]",***

***"=D\[\]\],***

*****s******em: "",***

*****p******hon: "", constituents: \["win"\]***

***\}***

![](Pictures/1002DEA400000447000009492F9E6783AEC414D4.svgPictures/100002010000001F000000437200C7C358C56F9A.png)

1)  The default ***strategy ***follows ***value ***with a ***compact
    ***step that handles both elimination of *valued*, *uninterpretable
    *features\[ˆcatfeat\] and any necessary **head incorporation**. For
    the implementation being demonstrated, **head incorporation
    **doesn’t follow from any linguistic principles — it is simply
    coded into the default ***strategy ***as a side-effect of valuation
    of a ***=V\[\] ***feature. Recall from chapter 4 that **head
    incorporation **in this system is simply a form of feature-sharing —
    specifically **donate**, in which all features from a given head are
    removed from that head’s **syn **list and prepended to the
    featurelist of a receiving head\[ˆphoninv\]. ***stage\_6 ***is in an
    **complete **state because there are no more actions the ***stage
    ***can plausibly take, as all ***probe ***and ***compact ***steps
    have completed, and there are no more items in its ***lexical array
    ***to draw from. Note that it is still not **convergent**, however,
    as there are unvalued features on some of its lexical items.

***DERIVATION***

***\{***

*****l******exical\_array: \[ \[\{"John"\}\],***

***\[\{"to\_inf"\}\],***

***\[\{"to-P"\}, \{"Mary"\}\],***

***\[\{"promise"\}, \{"v\_ditrans"\}\],***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***...,***

***\<stage\_6\>\], active\_stages: \[\<stage\_6\>\], state: "active",
convergent: false***

***\}***

***STAGE\_6***

***\{***

*****l******exical\_array: \[\],***

*****w******orkspace: \[\{"v\_intrans", "win"\}\], state: "complete",***

*****c******onvergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "v\_intrans", syn: \[***

***"cV\[win\]",***

***"cv\[intrans\]",***

***"=D\[\]\],***

*****s******em: "",***

*****p******hon: "", constituents: \["win"\]***

***\}***

![](Pictures/1001AD19000007E800000D6778CD2761AF2A007D.svgPictures/10000201000000390000006171AA2C6C05209C94.png)

1)  Because the active stage is **complete **but not **convergent**, the
    ***derivation ***leaves it on the list of active stages and begins
    the cycle anew with the next ***lexical array ***in its list.

***DERIVATION***

***\{***

*****l******exical\_array: \[ \[\{"to\_inf"\}\],***

***\[\{"to-P"\}, \{"Mary"\}\],***

***\[\{"promise"\}, \{"v\_ditrans"\}\],***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***...,***

***\<stage\_7\>\],***

*****a******ctive\_stages: \[\<stage\_7\>, \<stage\_6\>\], state:
"active",***

*****c******onvergent: false***

***\}***

***STAGE\_7***

***\{***

*****l******exical\_array: \[\{"John"\}\],***

*****w******orkspace: \[\], state: "designate", convergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "v\_intrans", syn: \[***

***"cV\[win\]",***

***"cv\[intrans\]",***

***"=D\[\]\],***

*****s******em: "",***

*****p******hon: "", constituents: \["win"\]***

***\}***

![](Pictures/10027441000007E800000D67E53B59FB972C6716.svgPictures/10000201000000390000006171AA2C6C05209C94.png)

1)  As before, since ***stage\_7 ***is in state “designate,” the
    ***strategy ***will instruct it to ***select ***from its ***lexical
    array***. There is only one possible target. Again, some minor steps
    are skipped here in which the ***strategy ***creates some
    intermediate ***stage***s on the way to determining that ***stage\_7
    ***is “born completed” — but also is not **convergent**. It is thus
    added to the ***history ***array but also retained as an active
    ***stage***.

***DERIVATION***

***\{***

*****l******exical\_array: \[ \[\{"to\_inf"\}\],***

***\[\{"to-P"\}, \{"Mary"\}\],***

***\[\{"promise"\}, \{"v\_ditrans"\}\],***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***...,***

***\<stage\_7\>\],***

*****a******ctive\_stages: \[\<stage\_7\>, \<stage\_6\>\], state:
"active",***

*****c******onvergent: false***

***\}***

***STAGE\_7***

***\{***

*****l******exical\_array: \[\], workspace: \[\{"John"\}\], state:
"complete", convergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "v\_intrans", syn: \[***

***"cV\[win\]",***

***"cv\[intrans\]",***

***"=D\[\]\],***

*****s******em: "",***

*****p******hon: "", constituents: \["win"\]***

***\}***

![](Pictures/1001747A000007E800000D6748E2DF851395FA8B.svgPictures/100002010000003900000061F7B4059B45390F3B.png)

1)  Because the ***derivation ***aims at having a single, **convergent
    **stage, it next compacts the existing active stages.

***DERIVATION***

***\{***

*****l******exical\_array: \[ \[\{"to\_inf"\}\],***

***\[\{"to-P"\}, \{"Mary"\}\],***

***\[\{"promise"\}, \{"v\_ditrans"\}\],***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***...,***

***\<stage\_8\>\], active\_stages: \[\<stage\_8\>\], state: "active",
convergent: false***

***\}***

***STAGE\_8***

***\{***

*****l******exical\_array: \[\],***

*****w******orkspace: \[\{"v\_intrans", "win"\}, \{"John"\}\], state:
"probe",***

*****c******onvergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "v\_intrans", syn: \[***

***"cV\[win\]",***

***"cv\[intrans\]",***

***"=D\[\]\],***

*****s******em: "",***

*****p******hon: "", constituents: \["win"\]***

***\},***

***\{***

*****t******ag: "John", syn: \[***

***"cD\[john\]",***

***"uCase\[\]"\], sem: "",***

*****p******hon: ""***

***\}***

![](Pictures/1002F327000007E8000016700111D1D0698164FC.svgPictures/1000020100000039000000A34223BCF25C69AEBC.png)

1)  The ***V-v ***tree is the active element (for no other reason than
    it is leftmost in the ***workspace***), so it ***probe***s. Again,
    the demonstration skips some steps here in the interest of space and
    clarity, but as before, ***v\_intrans ***will, by
    **merge-over-move**, try to ***probe ***the ***lexical array
    ***before ***probe***ing in the ***workspace***, and will of course
    find nothing, as the array is empty. It then proceeds to the
    ***workspace***, taking each item in turn. There is only one item —
    ***john — ***and the ***probe ***there is successful. Because it is
    a **select**or ***probe ***matching a **select**ee feature, ***merge
    ***is triggered. Each head involved then ***probe***s the other with
    any remaining ***probe***s. There are none on ***v\_intrans***.
    ***john ***has a ***uCase\[\] probe***, but it fails to find a
    match\[ˆtreedrawing\]. ***stage\_9 ***is thus **complete **but
    **divergent**.

***DERIVATION***

***\{***

*****l******exical\_array: \[ \[\{"to\_inf"\}\],***

***\[\{"to-P"\}, \{"Mary"\}\],***

***\[\{"promise"\}, \{"v\_ditrans"\}\],***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***...,***

***\<stage\_9\>\], active\_stages: \[\<stage\_9\>\], state: "active",
convergent: false***

***\}***

***STAGE\_9***

***\{***

*****l******exical\_array: \[\],***

*****w******orkspace: \[\{"John", \{"v\_intrans", "win"\}\}\], state:
"complete",***

*****c******onvergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "v\_intrans", syn: \[***

***"cV\[win\]",***

***"cv\[intrans\]",***

***"=D\[john\]\],***

*****s******em: "",***

*****p******hon: "",***

*****c******onstituents: \["win", "John"\]***

***\}***

![](Pictures/1001ABEC00000C4200001185AF00F0FB31179348.svgPictures/10000201000000590000007F8E2EC17409BCF66E.png)

1)  Because ***stage\_9 ***is **complete **but **divergent**, it remains
    on the active array. The

*****d******erivation ***creates a new ***stage ***from the next item in
the ***lexical array***.

***DERIVATION***

***\{***

*****l******exical\_array: \[***

***\[\{"to-P"\}, \{"Mary"\}\],***

***\[\{"promise"\}, \{"v\_ditrans"\}\],***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***...,***

***\<stage\_10\>\],***

*****a******ctive\_stages: \[\<stage\_10\>, \<stage\_9\>\], state:
"active",***

*****c******onvergent: false***

***\}***

***STAGE\_10***

***\{***

*****l******exical\_array: \[\{"to-inf"\}\], workspace: \[\],***

*****s******tate: "designate", convergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "v\_intrans", syn: \[***

***"cV\[win\]",***

***"cv\[intrans\]",***

***"=D\[john\]\],***

*****s******em: "",***

*****p******hon: "",***

*****c******onstituents: \["win", "John"\]***

***\}***

![](Pictures/1001813600000C4200001186F6B0C01E022F0498.svgPictures/10000201000000590000007F8E2EC17409BCF66E.png)

1)  As before, there is no other item in the ***lexical array***, so the
    stage simply completes without further ado (after, of course,
    failing to ***probe***).

***DERIVATION***

***\{***

*****l******exical\_array: \[***

***\[\{"to-P"\}, \{"Mary"\}\],***

***\[\{"promise"\}, \{"v\_ditrans"\}\],***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***...,***

***\<stage\_11\>\],***

*****a******ctive\_stages: \[\<stage\_11\>, \<stage\_9\>\], state:
"incomplete",***

*****c******onvergent: false***

***\}***

***STAGE\_11***

***\{***

*****l******exical\_array: \[\], workspace: \[\{"to-inf"\}\], state:
"complete", convergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "v\_intrans", syn: \[***

***"cV\[win\]",***

***"cv\[intrans\]",***

***"=D\[john\]\],***

*****s******em: "",***

*****p******hon: "",***

*****c******onstituents: \["win", "John"\]***

***\}***

![](Pictures/100182F400000CBE00001771F7E97F43B81E6F0B.svgPictures/100002010000005C000000AA1C6FA98485A2B93D.png)

1)  Once again, when the ***derivation ***is in an “incomplete” state
    with more than one active stage, it will compact them.

***DERIVATION***

***\{***

*****l******exical\_array: \[***

***\[\{"to-P"\}, \{"Mary"\}\],***

***\[\{"promise"\}, \{"v\_ditrans"\}\],***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***...,***

***\<stage\_12\>\], active\_stages: \[\<stage\_12\>\], state: "active",
convergent: false***

***\}***

***STAGE\_12***

***\{***

*****l******exical\_array: \[\],***

*****w******orkspace: \[\{"to-inf"\}, \{"John", \{"v\_intrans", "win"\}\}\],
state: "probe",***

*****c******onvergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "v\_intrans", syn: \[***

***"cV\[win\]",***

***"cv\[intrans\]",***

***"=D\[john\]\],***

*****s******em: "",***

*****p******hon: "",***

*****c******onstituents: \["win", "John"\]***

***\}***

![](Pictures/1001DD0700000C42000011856DFADEDB86221587.svgPictures/10000201000000590000007FE8F4EE47AEF8C3F0.png)

1)  *****t******o-inf ***probes the ***lexical array ***and finds it
    empty. Then it ***probe***s the assembled ***syntactic object
    ***representing ***v ***(“John win”) and finds a match for its
    **select **(***=v\[\]***) feature. As always, ***merge ***results.

***DERIVATION***

***\{***

*****l******exical\_array: \[***

***\[\{"to-P"\}, \{"Mary"\}\],***

***\[\{"promise"\}, \{"v\_ditrans"\}\],***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***...,***

***\<stage\_13\>\], active\_stages: \[\<stage\_13\>\], state: "active",
convergent: false***

***\}***

***STAGE\_13***

***\{***

*****l******exical\_array: \[\],***

*****w******orkspace: \[\{"to-inf", \{"John", \{"v\_intrans", "win"\}\}\}\],
state: "react",***

*****c******onvergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "to\_inf", syn:\[***

***"cT\[to\]",***

***"=v\[intrans\]",***

***"=D\[\]"\],***

*****s******em: "",***

*****p******hon: "",***

*****c******onstituents: \["v\_intrans"\]***

***\}***

![](Pictures/100207CB00000EE2000015A4A5743E2AD0B198BA.svgPictures/100002010000006C0000009D073D4D816D9D3FA9.png)

1)  After ***merge***, the ***stage ***is in a “react” ***state ***and
    so enters a mutual ***probe ***cycle. This happens to involve
    another ***select ***feature, and so begins the first instance of
    “move.” As per standard assumption, this is just ***re-merge***.
    The ***probe ***starts with ***v\_intrans***, finds no match, and so
    (recursively) continues along the ***constituents ***array of
    ***v\_intrans***. ***win ***is of course featurally empty, and in
    any case ***john ***is higher so is probed first. It finds a match
    on ***john***. ***John ***now appears in the ***constituents
    ***arrays of two objects — a multiattachment implementation. ***John
    ***again tries its ***case ***probe but is unable to find a match.

***DERIVATION***

***\{***

*****l******exical\_array: \[***

***\[\{"to-P"\}, \{"Mary"\}\],***

***\[\{"promise"\}, \{"v\_ditrans"\}\],***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***...,***

***\<stage\_14\>\], active\_stages: \[\<stage\_14\>\], state:
"incomplete", convergent: false***

***\}***

***STAGE\_14***

***\{***

*****l******exical\_array: \[\],***

*****w******orkspace: \[\{"John", \{"to-inf", \{"John", \{"v\_intrans",
"win"\}\}\}\}\], state: "complete",***

*****c******onvergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "to\_inf", syn:\[***

***"cT\[to\]",***

***"=v\[intrans\]",***

***"=D\[john\]"\], sem: "",***

*****p******hon: "",***

*****c******onstituents: \["v\_intrans", "John"\]***

***\}***

![](Pictures/100192CD0000133C000019C245B4F8C0E6CA0003.svgPictures/100002010000008C000000BBBD7ED4E1DF33E7FE.png)

1)  Finding itself in an “incomplete” state again, the ***derivation
    ***pulls out the next item from its ***lexical array ***and makes a
    new ***astage***

***DERIVATION***

***\{***

*****l******exical\_array: \[***

***\[\{"promise"\}, \{"v\_ditrans"\}\],***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***...,***

***\<stage\_15\>\],***

*****a******ctive\_stages: \[\<stage\_15\>, \<stage\_14\>\], state:
"active",***

*****c******onvergent: false***

***\}***

***STAGE\_15***

***\{***

*****l******exical\_array: \[\{"to-P"\}, \{"Mary"\}\], workspace: \[\],***

*****s******tate: "designate", convergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "to\_inf", syn:\[***

***"cT\[to\]",***

***"=v\[intrans\]",***

***"=D\[john\]"\], sem: "",***

*****p******hon: "",***

*****c******onstituents: \["v\_intrans", "John"\]***

***\}***

![](Pictures/100187340000133C000019C2EB1A36C108CD3F66.svgPictures/100002010000008C000000BBBD7ED4E1DF33E7FE.png)

1)  Again using as a selection heuristic that one element can select the
    other but not the other way around, the ***stage ***picks ***to-P***

***DERIVATION***

***\{***

*****l******exical\_array: \[***

***\[\{"promise"\}, \{"v\_ditrans"\}\],***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***...,***

***\<stage\_16\>\],***

*****a******ctive\_stages: \[\<stage\_16\>, \<stage\_14\>\], state:
"active",***

*****c******onvergent: false***

***\}***

***STAGE\_16***

***\{***

*****l******exical\_array: \[\{"Mary"\}\],***

*****w******orkspace: \[\{"to-P"\}\], state: "probe", convergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "to\_inf", syn:\[***

***"cT\[to\]",***

***"=v\[intrans\]",***

***"=D\[john\]"\], sem: "",***

*****p******hon: "",***

*****c******onstituents: \["v\_intrans", "John"\]***

***\}***

![](Pictures/1001ECB70000133C000019C28BFFF5A8355DF087.svgPictures/100002010000008C000000BBBD7ED4E1DF33E7FE.png)

1)  *****t******o-P ***finds a match for its **select **feature, so
    ***Mary ***is moved to the ***workspace***, ***merge ***results, and
    the two ***merge***d items ***probe ***each other. This results in a
    valuation of the case feature on ***Mary***.\[ˆskipreact\]

***DERIVATION***

***\{***

*****l******exical\_array: \[***

***\[\{"promise"\}, \{"v\_ditrans"\}\],***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***...,***

***\<stage\_17\>\],***

*****a******ctive\_stages: \[\<stage\_17\>, \<stage\_14\>\], state:
"active",***

*****c******onvergent: false***

***\}***

***STAGE\_17***

***\{***

*****l******exical\_array: \[\],***

*****w******orkspace: \[\{"to-P", "Mary"\}\], state: "complete",
convergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "to\_inf", syn:\[***

***"cT\[to\]",***

***"=v\[intrans\]",***

***"=D\[john\]"\], sem: "",***

*****p******hon: "",***

*****c******onstituents: \["v\_intrans", "John"\]***

***\},***

***\{***

*****t******ag: "to-P", syn: \[***

***"cPDat\[pdat\]",***

***"=D\[mary\]",***

***"iCase\[dat\]"\], sem: "",***

*****p******hon: "",***

*****c******onstituents: \["Mary"\]***

***\}***

![](Pictures/1001B07C000013490000273017ADD8ED321A919A.svgPictures/100002010000008C0000011C5341FE576B29109A.png)

1)  Again, the ***derivation ***compacts the active stages. However,
    this time it doesn’t help — there are no features on either element
    that will allow for **select**ion of the other.

***DERIVATION***

***\{***

*****l******exical\_array: \[***

***\[\{"promise"\}, \{"v\_ditrans"\}\],***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***...,***

***\<stage\_18\>\], active\_stages: \[\<stage\_18\>\], state: "active",
convergent: false***

***\}***

***STAGE\_18***

***\{***

*****l******exical\_array: \[\], workspace: \[***

***\{"to-P", "Mary"\},***

***\{"John", \{"to-inf", \{"John", \{"v\_intrans", "win"\}\}\}\}***

***\],***

*****s******tate: "complete", convergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "to\_inf", syn:\[***

***"cT\[to\]",***

***"=v\[intrans\]",***

***"=D\[john\]"\], sem: "",***

*****p******hon: "",***

*****c******onstituents: \["v\_intrans", "John"\]***

***\},***

***\{***

*****t******ag: "to-P",***

*****s******yn: \[***

***"cPDat\[pdat\]",***

***"=D\[mary\]",***

***"iCase\[dat\]"\], sem: "",***

*****p******hon: "", constituents: \["Mary"\]***

***\}***

![](Pictures/1001478B0000134900002730489E300C3D7146E9.svgPictures/100002010000008C0000011C5341FE576B29109A.png)

1)  So the ***derivation ***must create a new ***stage ***from an item
    in its ***lexical array***.

***DERIVATION***

***\{***

*****l******exical\_array: \[***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***...,***

***\<stage\_19\>\],***

*****a******ctive\_stages: \[\<stage\_19\>, \<stage\_18\>\], state:
"incomplete",***

*****c******onvergent: false***

***\}***

***STAGE\_19***

***\{***

*****l******exical\_array: \[\{"promise"\}, \{"v\_ditrans"\}\], workspace:
\[\]***

*****s******tate: "designate", convergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "to\_inf", syn:\[***

***"cT\[to\]",***

***"=v\[intrans\]",***

***"=D\[john\]"\], sem: "",***

*****p******hon: "",***

*****c******onstituents: \["v\_intrans", "John"\]***

***\},***

***\{***

*****t******ag: "to-P", syn: \[***

***"cPDat\[pdat\]",***

***"=D\[mary\]",***

***"iCase\[dat\]"\], sem: "",***

*****p******hon: "", constituents: \["Mary"\]***

***\}***

![](Pictures/10013F100000134900002730C79C952AD74617C8.svgPictures/100002010000008C0000011C5341FE576B29109A.png)

1)  Heuristics select the item that can select the other.

***DERIVATION***

***\{***

*****l******exical\_array: \[***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***...,***

***\<stage\_20\>\],***

*****a******ctive\_stages: \[\<stage\_20\>, \<stage\_18\>\], state:
"incomplete",***

*****c******onvergent: false***

***\}***

***STAGE\_20***

***\{***

*****l******exical\_array: \[\{"promise"\}\], workspace:
\[\{"v\_ditrans"\}\] state: "probe",***

*****c******onvergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "to\_inf", syn:\[***

***"cT\[to\]",***

***"=v\[intrans\]",***

***"=D\[john\]"\], sem: "",***

*****p******hon: "",***

*****c******onstituents: \["v\_intrans", "John"\]***

***\},***

***\{***

*****t******ag: "to-P", syn: \[***

***"cPDat\[pdat\]",***

***"=D\[mary\]",***

***"iCase\[dat\]"\], sem: "",***

*****p******hon: "", constituents: \["Mary"\]***

***\}***

![](Pictures/10015D660000134900002730BADDFEC1E07FF4E7.svgPictures/100002010000008C0000011C5341FE576B29109A.png)

1)  Glossing over the details of the ***probe ***cycle, ***promise ***is
    **selected **and ***merge***d

***DERIVATION***

***\{***

*****l******exical\_array: \[***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***...,***

***\<stage\_21\>\],***

*****a******ctive\_stages: \[\<stage\_21\>, \<stage\_18\>\], state:
"incomplete",***

*****c******onvergent: false***

***\}***

***STAGE\_21***

***\{***

*****l******exical\_array: \[\],***

*****w******orkspace: \[\{"v\_ditrans", "promise"\}\] state: "react",***

*****c******onvergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "to\_inf", syn:\[***

***"cT\[to\]",***

***"=v\[intrans\]",***

***"=D\[john\]"\], sem: "",***

*****p******hon: "",***

*****c******onstituents: \["v\_intrans", "John"\]***

***\},***

***\{***

*****t******ag: "to-P", syn: \[***

***"cPDat\[pdat\]",***

***"=D\[mary\]",***

***"iCase\[dat\]"\], sem: "",***

*****p******hon: "", constituents: \["Mary"\]***

***\},***

***\{***

*****t******ag: "v\_ditrans", syn: \[***

***"cv\[ditrans\]", "=VDitrans\[promise\]", "=D\[\]"\]***

*****s******em: "",***

*****p******hon: "",***

*****c******onstituents: \["promise"\]***

***\}***

![](Pictures/1000DC1B0000133C000019C2B5B435E5E7829C84.svgPictures/100002010000008C000000BBBD7ED4E1DF33E7FE.png)

![](Pictures/10014A9A000006FD00001B1C496E2C60589E518C.svgPictures/1000020100000033000000C52C466E12E0F90EC8.png)

1)  Again, there is **head movement**

***DERIVATION***

***\{***

*****l******exical\_array: \[***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***...,***

***\<stage\_22\>\],***

*****a******ctive\_stages: \[\<stage\_22\>, \<stage\_18\>\], state:
"incomplete",***

*****c******onvergent: false***

***\}***

***STAGE\_22***

***\{***

*****l******exical\_array: \[\],***

*****w******orkspace: \[\{"v\_ditrans", "promise"\}\] state:
"complete",***

*****c******onvergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "to\_inf", syn:\[***

***"cT\[to\]",***

***"=v\[intrans\]",***

***"=D\[john\]"\], sem: "",***

*****p******hon: "",***

*****c******onstituents: \["v\_intrans", "John"\]***

***\},***

***\{***

*****t******ag: "to-P", syn: \[***

***"cPDat\[pdat\]",***

***"=D\[mary\]",***

***"iCase\[dat\]"\], sem: "",***

*****p******hon: "", constituents: \["Mary"\]***

***\},***

***\{***

*****t******ag: "v\_ditrans", syn: \[***

***"cVDitrans\[promise\]",***

***"=T\[\]",***

***"=PDat\[\]",***

***"cv\[ditrans\]", "=VDitrans\[promise\]", "=D\[\]"\],***

*****s******em: "",***

*****p******hon: "",***

*****c******onstituents: \["promise"\]***

***\}***

~~~~

~~~~

~~~~

~~~~

1)  Again, the ***stage***s compact

***DERIVATION***

***\{***

*****l******exical\_array: \[***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***...,***

***\<stage\_23\>\], active\_stages: \[\<stage\_23\>\], state: "active",
convergent: false***

***\}***

***STAGE\_23***

***\{***

*****l******exical\_array: \[\], workspace: \[***

***\{"v\_ditrans", "promise"\},***

***\{"to-P", "Mary"\},***

***\{"John", \{"to-inf", \{"John", \{"v\_intrans", "win"\}\}\}\}***

***\],***

*****s******tate: "probe", convergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "to\_inf", syn:\[***

***"cT\[to\]",***

***"=v\[intrans\]",***

***"=D\[john\]"\], sem: "",***

*****p******hon: "",***

*****c******onstituents: \["v\_intrans", "John"\]***

***\},***

***\{***

*****t******ag: "to-P", syn: \[***

***"cPDat\[pdat\]",***

***"=D\[mary\]",***

***"iCase\[dat\]"\], sem: "",***

*****p******hon: "", constituents: \["Mary"\]***

***\},***

***\{***

*****t******ag: "v\_ditrans", syn: \[***

***"cVDitrans\[promise\]", "=T\[\]",***

***"=PDat\[\]",***

***"cv\[ditrans\]", "=VDitrans\[promise\]", "=D\[\]"\],***

*****s******em: "",***

*****p******hon: "",***

*****c******onstituents: \["promise"\]***

***\}***

~~~~

~~~~

~~~~

1)  The first active ***probe ***on ***v\_ditrans — ***which is
    ***=T\[\] ***after **head incorporation — **will find no match on
    the ***to\_p***, but will on the TP, resulting, as always, in
    ***merge ***and mutual ***probe***. This technically results in the
    TP ***merge***ing with *v*, but as noted in chapter 4, this is
    ultimately notational. The relative hierarchy of elements is
    preserved, with ***mary ***“outranking” the TP and ***john
    ***(ultimately) outranking both. The display algorithm is able to
    produce a normal binary-branching tree from this nothwithstanding

based on the relative ordering of the selectional features
(***=T\[\]***, ***=PDat\[\]***, ***=D\[\]***) and the categorial
features (***cVDitrans\[promise\]***, ***cv\[ditrans\]***)

***DERIVATION***

***\{***

*****l******exical\_array: \[***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***...,***

***\<stage\_24\>\], active\_stages: \[\<stage\_24\>\], state: "active",
convergent: false***

***\}***

***STAGE\_24***

***\{***

*****l******exical\_array: \[\], workspace: \[***

***\{***

***\{"v\_ditrans", "promise"\},***

***\{"John", \{"to-inf", \{"John", \{"v\_intrans", "win"\}\}\}\}***

***\},***

***\{"to-P", "Mary"\},***

***\],***

*****s******tate: "react", convergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "to-P", syn: \[***

***"cPDat\[pdat\]",***

***"=D\[mary\]",***

***"iCase\[dat\]"\], sem: "",***

*****p******hon: "", constituents: \["Mary"\]***

***\},***

***\{***

*****t******ag: "v\_ditrans", syn: \[***

***"cVDitrans\[promise\]", "=T\[to\]",***

***"=PDat\[\]",***

***"cv\[ditrans\]", "=VDitrans\[promise\]", "=D\[\]"\],***

*****s******em: "",***

*****p******hon: "",***

*****c******onstituents: \["promise", "to\_inf"\]***

***\}***

![](Pictures/1000CCFD000005F800000994E075F8E32C509542.svgPictures/100002010000002B00000045BAD383BBBE451237.png)

![](Pictures/10017E0E000021DF000021FFB2AD43B8E359C987.svgPictures/10000201000000F6000000F7BEAE79AC83F3A0EB.png)

1)  The next **select *****probe ***finds a match on the remaining item
    in the ***workspace***

***DERIVATION***

***\{***

*****l******exical\_array: \[***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***...,***

***\<stage\_25\>\], active\_stages: \[\<stage\_25\>\], state: "active",
convergent: false***

***\}***

***STAGE\_25***

***\{***

*****l******exical\_array: \[\], workspace: \[***

***\{***

***\{\{"v\_ditrans", "promise"\},***

***\{"John", \{"to-inf", \{"John", \{"v\_intrans", "win"\}\}\}\}\},***

***\{"to-P", "Mary"\}***

***\}***

***\],***

*****s******tate: "react", convergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "to-P", syn: \[***

***"cPDat\[pdat\]",***

***"=D\[mary\]",***

***"iCase\[dat\]"\], sem: "",***

*****p******hon: "", constituents: \["Mary"\]***

***\},***

***\{***

*****t******ag: "v\_ditrans", syn: \[***

***"cVDitrans\[promise\]", "=T\[to\]",***

***"=PDat\[pdat\]",***

***"cv\[ditrans\]", "=VDitrans\[promise\]", "=D\[\]"\],***

*****s******em: "",***

*****p******hon: "",***

*****c******onstituents: \["promise", "to\_inf", "to-P"\]***

***\}***

![](Pictures/1002B1A4000029280000261D0E77439454B05EC1.svgPictures/100002010000012B00000115911D1A83846C6391.png)

1)  (**The crucial step — **HEAD INCORPORATION) At this point, things
    get murky, as the original article is a little unclear. If **head
    incorporation **is going to happen, it pretty much has to happen now
    (especially given the authors’ insistence that their analysis of the
    ungrammaticality of the passive counterpart is forced by strict
    adherence to cyclicity). However, if **head incorporation **happens,
    it would make ***Mary ***a blocking category for subsequent raising
    of ***John ***to subject, which is indeed the next step (because
    ***v\_ditrans ***still has one unvalued **select**or feature —
    ***=D\[\]***). At least, this is true if the same consequences
    result from **head incorporation **as were assumed to result from it
    in the analysis of the passive counterpart. Recall that in that
    analysis, the ungrammatical reading of *Mary was promised (by John)
    to win *in which the *promiser *(possibly *John*) is also the winner
    (represented by an unpronounced *pro *in the external argument
    position of *v *which has raised to this position from the subject
    position of the lower TP — i.e. *Mary*<sub>i </sub>*was Mary*<sub>i
    </sub>*pro*<sub>j </sub>*Mary*<sub>i </sub>*promised pro*<sub>j
    </sub>*to win*) was ruled out by appeal to the notion that **head
    incorporation **of an unpronounced P head caused a category shift of
    *to Mary *from PP to DP, making it an intervener at the moment when
    *pro *would otherwise raise to fill the external argument position
    of *v*. There’s no problem with *pro *filling this position, it just
    can’t be *the same pro *that is in the lower clause — i.e. it must
    be ***merge***d in from the ***lexical array***. Obviously this
    logic also serves to block *John *raising in exactly the same way in
    the current derivation. Discussion continues below, after
    illustration of the **head incorporation **step.

***DERIVATION***

***\{***

*****l******exical\_array: \[***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[***

***\<stage\_1\>,***

***...,***

***\<stage\_26\>\], active\_stages: \[\<stage\_26\>\], state: "active",
convergent: false***

***\}***

***STAGE\_26***

***\{***

*****l******exical\_array: \[\], workspace: \[***

***\{***

***\{\{"v\_ditrans", "promise"\},***

***\{"John", \{"to-inf", \{"John", \{"v\_intrans", "win"\}\}\}\}\}, "Mary"***

***\}***

***\],***

*****s******tate: "react", convergent: false***

***\}***

***ASSEMBLED TREES***

***\{***

*****t******ag: "v\_ditrans", syn: \[***

***"cVDitrans\[promise\]", "=T\[to\]",***

***"=PDat\[pdat\]",***

***"cv\[ditrans\]", "=VDitrans\[promise\]", "=D\[\]"\],***

*****s******em: "",***

*****p******hon: "",***

*****c******onstituents: \["promise", "to\_inf", "Mary"\]***

***\}***

![](Pictures/10049505000026950000261D5DE67B8CF8A13BC5.svgPictures/1000020100000118000001152D4090AF5BC0A724.png)

Notice this is not the same kind of **head incorporation **used earlier.
The mechanics of the operation are left up to the ***strategy***. In
this implementation, **select **of a ***cPDat\[pdat\] ***category causes
the *selectee *to restructure, essentially eliminating the PP
shell\[ˆstrategyimpl\]. Since ***stage\_25 ***is still in a “react”
state, as a result of the ***merge***, it will attempt its final

***=D\[\] probe ***on its ***constituents ***list (as there are no items
in the ***lexical array***). What happens here depends greatly on
implementation details.

The obvious thing to happen is for the probe to work backward through
the ***constituents ***array (as this directly corresponds to
hierarchy). In this case, the ***probe ***will find a match on ***Mary
***and stop, ultimately crashing the derivation (as there are no more
D-category items in the ***derivation***s remaining inventory of lexical
items). This will happen again at the T stage

\- the T probe will find ***Mary ***first and stop. T will never find a
match for its **select**or feature (an EPP violation) and ***John
***will never get case. The derivation will assemble a complete tree,
but with unvalued features. The interfaces will reject the result.

There are plausible ways to save the derivation, however. One could
model a system where **head incorporation **does NOT happen unless *v
*is passive. This could be done by specifying two kinds of ***to-P ***in
the lexicon, one selected by passive *v *and one by the active version,
and write the ***strategy ***in a way that only the former incorporates.
A PF rule would then decide whether the P were pronounced.

Superficially, this is quite appealing, as pronounciation of *to *seems
structurally dependent anyway\[ˆpronounceto\]. But it ultimately begs a
lot of questions, foremost among them why incorporation should be
dependent on the presence or absence of a *passive *structure. Absent
such an explanation, it would merely be a hack to get the desired
result. Moreover, nothing would actually prevent inclusion of a *pro *in
the original ***lexical array ***alongside ***John***. Consider, for
example, what happens with this starting ***lexical array ***instead of
the one shown:

***\{***

*****l******exical\_array: \[ \[\{"v\_intrans"\}, \{"win"\}\],
\[\{"pro"\}\],***

***\[\{"to\_inf"\}\],***

***\[\{"to-P"\}, \{"Mary"\}\], \[\{"John"\}\],***

***\[\{"promise"\}, \{"v\_ditrans"\}\],***

***\[\{"T-past"\}, \{"C"\}\]\],***

*****h******istory: \[\], active\_stages: \[\], state: "start"***

***\}***

Running the system with this array converges without problem. *pro *sits
in the subject position of the lower clause, and by **merge-over-move**,
***John ***is prefered over raising *pro *to the external argument
position of *v *anyway. The intervention issue never arises: it simply
doesn’t matter whether P incorporates or not. Since *pro *does not need
case, there is no problem with it staying in the SPEC-*to*. This derives
a sentence where *John promised Mary to win *means that John promised
Mary that some third person — neither John nor Mary — would win, an
unavailable reading. The only real solution would be to somehow prevent
*pro *from appearing in the subject position of the lower clause, but
that would obviate the need for this analysis in the first place (as the
whole point was to account for why, in a raising analysis, *pro *could
not raise to subject in the passive). More to the point, stipulating
what kinds of objects can appear in SPEC-to is conceding defeat, since
this more or less recreates PRO-type analyses.

### <span id="anchor-126"></span><span id="anchor-127"></span>FINAL STEPS

It should be obvious how the derivation proceeds from here. Only the
“late-to-never” incorpo- ration analysis will work — that is, for the
active sentence to go through, incorporation has to be dependent on the
presence of the passive morpheme in the way described above. The reader
can verify that the feature setup on the remaining items will work. ***T
***and ***C ***merge and feature-share in the same way that
***v\_ditrans ***and ***promise ***did, and ***T ***then attracts
***John ***to its SPEC, the side-effect of which is that ***John
***satisfies its case requirement. The ***derivation ***is left with an
empty ***lexical array ***and a single, **convergent **(all features are
valued), active stage. This is the **convergence **condition for
***derivation***s.

## <span id="anchor-128"></span>Appendix B — Problem Solving in the System

This section starts with a straightfoward derivation to show the system
functioning properly. It then gives a brief overview of some failure
patterns. In the interests of space, no derivations are completely
worked out. For a complete derivation, the reader is refered to Appendix
A.

### <span id="anchor-129"></span>**PARROTS LIKE NUTS**

The lexicon used for this derivation is given in Appendix C. The start
state is as follows:

***DERIVATION***

***\{***

*****l******exical\_array: \[ \[\{"det"\}, \{"parrots"\}\],***

***\[\{"det"\}, \{"nuts"\}\],***

***\[\{"v\_trans"\}, \{"like"\}\],***

***\[\{"C"\}, \{"T"\}\]***

***\],***

*****h******istory: \[\], active\_stages: \[\], state: "start"***

***\}***

From there, the system will form each of the DPs in turn. This process
starts with a ***stage***

formed from one of the ***lexical array***s.

***STAGE***

***\{***

*****l******exical\_array: \[\{"det"\}, \{"parrots"\}\], workspace: \[\],***

*****s******tate: "designate", convergent: false***

***\}***

The ***stage ***will determine that while ***det ***can select
***parrots ***(because of its ***=N\[\] ***feature),

*****p******arrots ***can’t select ***det***. So, it will start by
pulling out ***det ***as the active item:

***STAGE***

***\{***

*****l******exical\_array: \[\{"parrots"\}\], workspace: \[\{"det"\}\],***

*****s******tate: "probe", convergent: false***

***\}***

Which will probe and find ***parrots ***in the lexical array:

***STAGE***

***\{***

*****l******exical\_array: \[\],***

*****w******orkspace: \[\{"det"\}, \{"parrots"\}\], state: "react",***

*****c******onvergent: false***

***\}***

Which will trigger ***merge***

***STAGE***

***\{***

*****l******exical\_array: \[\],***

*****w******orkspace: \[\{"det", "parrots"\}\], state: "complete",***

*****c******onvergent: false***

***\}***

At this point, there is a tree:

***\{***

*****t******ag: "det", syn: \[***

***"cD\[det\]",***

***"=N\[parrots\]",***

***"cCase\[\]"***

***\],***

*****s******em: "",***

*****p******hon: "",***

*****c******onstituents: \["parrots"\]***

***\}***

where a “tree” in this system is represented in a ***syntactic object
***type data structure.

This stage is complete — because there are no more actions it can take,
but not convergent, because there are unvalued features
(***uCase\[\]***). It sits in the ***active stages ***array until it can
be reintegrated into the derivation:

***\{***

*****l******exical\_array: \[ \[\{"det"\}, \{"nuts"\}\],***

***\[\{"v\_trans"\}, \{"like"\}\],***

***\[\{"C"\}, \{"T"\}\]***

***\],***

*****h******istory: \[..., \<parrots\_stage\>\], active\_stages:
\[\<parrots\_stage\>\], state: "active"***

***\}***

The ***derivation ***has nothing to do at this point but start again
with another stage. So, leaving (a pointer to) the previous ***stage
***in the ***active stages ***array, it makes a new ***stage ***and
starts operating on that. This repeats the same process as before:

***DERIVATION***

***\{***

*****l******exical\_array: \[ \[\{"v\_trans"\}, \{"like"\}\],***

***\[\{"C"\}, \{"T"\}\]***

***\],***

*****h******istory: \[..., \<nuts\_stage\>\],***

*****a******ctive\_stages: \[\<nuts\_stage\>, \<parrots\_stage\>\],
state: "active"***

***\}***

Next up is the v stage.

***\{***

*****l******exical\_array: \[ \[\{"C"\}, \{"T"\}\]***

***\],***

*****h******istory: \[..., \<nuts\_stage\>\],***

*****a******ctive\_stages: \[\<nuts\_stage\>, \<parrots\_stage\>\],
state: "active"***

***\}***

***STAGE***

***\{***

*****l******exical\_array: \[\{"v\_trans"\}, \{"like"\}\], workspace:
\[\],***

*****s******tate: "react", convergent: false***

***\}***

Which, as the reader can verify from feature selection, will end up like
this:

***STAGE***

***\{***

*****l******exical\_array: \[\],***

*****w******orkspace: \[\{"v\_trans", "like"\}\], state: "react",***

*****c******onvergent: false***

***\}***

with ***v\_trans ***having ***merge***d with ***like — ***yielding the
following tree:

***\{***

***"tag": "v\_trans", "syn": \[***

***"cv\[trans\]",***

***"=V\[like\]",***

***"=D\[\]",***

***"iCase\[acc\]"***

***\],***

***"sem": "",***

***"phon": "", constituents: \["like"\]***

***\}***

At this point, the ***like ***head incorporates, effectively turning
this tree into a single node. **incorporation **is a side effect of
certain ***select***or features. This is scriptable by changing the
definition of the ***strategy ***that guides the derivation (see Chapter
4). For the purpose of this derivation, it is assumed to fire whenever a
***=V\[\] ***or ***=T\[\] ***feature is valued. **head incorporation
**is implemented by **donate **(see Chapter 4, section on Feature
Inheritance), meaning ***v\_trans ***simply picks up all of the features
on ***V***. Specifically, these are *prepended *to its own feature list
(to ensure that operations remain cyclic — that is, the object, required
by V, will be selected before the subject, required by v, etc.)

***\{***

***"tag": "v\_trans", "syn": \[***

***"cV\[like\]",***

***"=D\[\]",***

***"cv\[trans\]",***

***"=V\[like\]",***

***"=D\[\]",***

***"iCase\[acc\]"***

***\],***

***"sem": "",***

***"phon": "", constituents: \["like"\]***

***\}***

*****v******\_trans ***now has ***like***’s ***=D\[\] ***requirement in
addition to its own. This makes the remaining two stages on the
***active\_stages ***array **select**able, since they feature ***D
***heads.

***DERIVATION***

***\{***

*****l******exical\_array: \[ \[\{"C"\}, \{"T"\}\]***

***\],***

*****h******istory: \[..., \<v\_stage\>\],***

*****a******ctive\_stages: \[\<v\_stage\>, \<nuts\_stage\>,
\<parrots\_stage\>\], state: "start"***

***\}***

Following obvious order, the system first ***merge***s
***\<nuts\_stage\> ***with ***\<v\_stage\>***, which means concatenating
the ***stage***s ***lexical\_array***s (vacuous, since they’re both
exhausted)

***STAGE***

***\{***

*****l******exical\_array: \[\],***

*****w******orkspace: \[\{"v\_trans", "like"\}, \{"det", "nuts"\}\],***

*****s******tate: "probe", convergent: false***

***\}***

This can be **select**ed by the head, so ***merge ***results:

***STAGE***

***\{***

*****l******exical\_array: \[\],***

*****w******orkspace: \[\{\{"v\_trans", "like"\}, \{"det", "nuts"\}\}\],
state: "probe",***

*****c******onvergent: false***

***\}***

***\{***

***"tag": "v\_trans", "syn": \[***

***"cV\[like\]",***

***"=D\[det\]",***

***"cv\[trans\]",***

***"=V\[like\]",***

***"=D\[\]",***

***"iCase\[acc\]"***

***\],***

***"sem": "",***

***"phon": "",***

*****c******onstituents: \["like", "det"\]***

***\}***

As a side-effect, ***det ***is able to counter-***probe ***and gets its
***case ***feature valued as a result.

***\{***

***"tag": "det", "syn": \[***

***"cD\[det\]",***

***"=N\[nuts\]",***

***"uCase\[acc\]"***

***\],***

***"sem": "",***

***"phon": ""***

***\}***

A critical step at this point is ***compact***, which needs to eliminate
the ***case ***feature from ***v\_trans ***(or else it will get
transmitted again in the next step, which ***merge***s the subject).
More details are given in later sections. Again, side-effects are
user-definable — they can be written into the scripted ***strategy***.

This process repeats with the output of the ***parrots stage***, and the
entire v-complex is now assembled.

***\{***

***"tag": "v\_trans", "syn": \[***

***"cV\[like\]",***

***"=D\[det\]",***

***"cv\[trans\]",***

***"=V\[like\]",***

***"=D\[parrots\]"***

***\],***

***"sem": "",***

***"phon": "",***

*****c******onstituents: \["like", "det", "det"\]***

***\}***

In the next step, the ***C-T ***complex is formed, again involving
**feature inheritance**:

***STAGE***

***\{***

*****l******exical\_array: \[\], workspace: \[\{"C", "T"\}\], state:
"react", convergent: false***

***\}***

***DERIVATION***

***\{***

*****l******exical\_array: \[***

***\],***

*****h******istory: \[..., \<v\_stage\>, \<c\_t\_stage\>\],
active\_stages: \[\<c\_t\_stage\>, \<v\_stage\>\], state: "active"***

***\}***

***\{***

***"tag": "C", "syn": \[***

***"cT\[pres\]",***

***"=v\[\]",***

***"=D\[\]",***

***"=uPhi\[\]",***

***"iCase\[nom\]",***

***"cC\[decl\]",***

***"=T\[pres\]"***

***\],***

***"sem": "",***

***"phon": "",***

***"constituents": \["T"\]***

***\}***

The two remaining active ***stage***s ***merge***, and ***C-T ***is able
to select its arguments in turn — first ***v\_trans ***itself, and
second the subject (to satisfy the ***=D\[\] ***feature). Here is the
state of the tree just before ***probe***ing for the subject:

***\{***

***"tag": "C", "syn": \[***

***"cT\[pres\]",***

***"=v\[trans\]",***

***"=D\[\]",***

***"=uPhi\[\]",***

***"iCase\[nom\]",***

***"cC\[decl\]",***

***"=T\[pres\]"***

***\],***

***"sem": "",***

***"phon": "",***

***"constituents": \["T", "v\_trans"\]***

***\}***

There are no items in the ***constituents ***list with the requisite
features, of course, so the ***probe ***will recursively ***probe
***into each item in the ***constituents ***array *in reverse order
*(i.e. in order of hierarchy). (Notice that this behavior is scriptable,
so that systems that need to enforce in-phase equidistance, for example,
can ***probe ***all items simultaneously.) This finds the subject (as
the first of the two ***det***s in the ***constituents ***array of
***v\_trans — ***see above). As a side-effect, ***T ***can value its
***uPhi\[\] ***features, and ***det ***can value its ***uCase\[\]
***feature:

***\{***

***"tag": "C", "syn": \[***

***"cT\[pres\]",***

***"=v\[trans\]",***

***"=D\[parrots\]",***

***"=uPhi\[3pl\]",***

***"iCase\[nom\]",***

***"cC\[decl\]",***

***"=T\[pres\]"***

***\],***

***"sem": "",***

***"phon": "",***

***"constituents": \["T", "v\_trans", "det"\]***

***\}***

The ***derivation ***converges, because:

1.  There are no remaining items in its ***lexical array***
2.  There is a singular active ***stage***
3.  This stage is *convergent*

The ***stage ***is *convergent *because:

1.  There are no remaining items in its ***lexical array***
2.  There is a single remaining item in its ***workspace***
3.  There are no unvalued, negative-polarity (***= ***and ***u***)
    features on its **head **or on the **head**s of any of its
    constituents

***DERIVATION***

***\{***

*****l******exical\_array: \[\],***

*****h******istory: \[..., \<v\_stage\>, \<c\_t\_stage\>\],
active\_stages: \[\<c\_t\_stage\>\],***

*****s******tate: "convergent"***

***\}***

### <span id="anchor-130"></span>SOME FAILURE PATTERNS

To truly understand a system, it is important to know not only how it
succeeds, but also how it can fail. More specifically, the purpose of a
system like this one is to allow for a series of “what-if”s — so that
researchers can explore the (unintended) consequences of minor changes
in system architecture.

Two such potential alterations were hinted at above:

1.  *What if **probe ***were simultaneous, as it is necessary for it to
    be for some analyses to work?
2.  *What if **compact ***didn’t fire after valuing an uninterpretable
    feature? That is, *what if *the feature were allowed to participate
    in more than one relationship?

Both of these require alternations in the ***strategy ***file.

In the first case, the required change is to ***probe ***all members of
the target’s ***constituents ***array at once, returning a list, and
then picking the most suitable object from the list. Simultaneous
***probe ***of this kind mimics analyses where everything in the phase
periphery is equidistant\[ˆequid\].

THe relevant stage from the derivation above involves ***probe ***of
this tree for the subject

***\{***

***"tag": "v\_trans", "syn": \[***

***"cV\[like\]",***

***"=D\[det\]",***

***"cv\[trans\]",***

***"=V\[like\]",***

***"=D\[parrots\]"***

***\],***

***"sem": "",***

***"phon": "",***

*****c******onstituents: \["like", "det", "det"\]***

***\}***

Rather than simply considering the first ***det ***(***parrots***), the
system will consider both.

Is there anything to distinguish them at this point? There is: case. At
this stage in the derivation, each DP looks like this, respectively:

***\{***

***"tag": "det", "syn": \[***

***"cD\[det\]",***

***"=N\[nuts\]",***

***"uCase\[acc\]"***

***\],***

***"sem": "",***

***"phon": "",***

***"constituents": \["nuts"\]***

***\}***

***\{***

***"tag": "det", "syn": \[***

***"cD\[det\]",***

***"=N\[parrots\]",***

***"uCase\[\]"***

***\],***

***"sem": "",***

***"phon": "", "constituents": \["parrots"\]***

***\}***

So this is not necessarily a fatal move for this particular derivation.
If the system picks randomly and chooses ***nuts***, the derivation will
crash in the end, because although it will reach the final stage as
before, it will now *NOT *be the case that all negative-polarity
features are valued within the single remaning ***stage***.

However, adding the second *what if — *“what if ***compact ***didn’t
fire after valuing a feature?” — and running the system removes this
escape hatch. This is because the subject will be valued with ***acc
***case by ***v\_trans ***just like the object is. The relevant step is
here:

***\{***

***"tag": "v\_trans", "syn": \[***

***"cV\[like\]",***

***"=D\[det\]",***

***"cv\[trans\]",***

***"=V\[like\]",***

***"=D\[\]"***

***"iCase\[acc\]"***

***\],***

***"sem": "",***

***"phon": "",***

*****c******onstituents: \["like", "det"\]***

***\}***

This happens just after the first of the two pre-assembled ***active
stage***s are ***merge***d with the

***\<v\_stage\> ***stage. This much has been successful, of course; the
***derivation ***looks like this:

***DERIVATION***

***\{***

*****l******exical\_array: \[ \[\{"C"\}, \{"T"\}\]***

***\],***

*****h******istory: \[..., \<v\_stage\>\],***

*****a******ctive\_stages: \[\<v\_stage\>, \<parrots\_stage\>\],***

*****s******tate: "active"***

***\}***

The ***active\_stages ***will ***merge ***causing ***v\_trans ***and
***det ***(parrots) to end up in the same ***workspace ***which will
cause ***v\_trans ***to try to ***probe det(parrots) ***which succeeds
because ***det ***is a ***cD\[det\] ***and ***probe ***is ***=D\[\]***.
This triggers a ***merge ***which in turn triggers a round of mutual
***probe***ing, which means that if ***v\_trans***’ ***iCase\[acc\]
***feature has not been eliminated by ***compact ***that ***parrots
***will find a match. This is not a problem, of course, without multiple
probe\[ˆmultiplevalue\]. But with multiple ***probe ***it eliminates the
remaining way the system has to disambiguage the “equidistant” items. Of
course, all this assumes that the implementation of muitple ***probe
***allows the system to look at *all *items in the ***constituents
***array. Coding the ***strategy ***carefully enough to avoid the
***complement ***would obviate the problem.

The point here has, of course, not to argue for or against any of these
potential failure patterns. Rather, it illustrates the principle that
minor tweaks in the algorithm can have derivation-wide consequences.
That is to say, it illustrates the point of this project.

## <span id="anchor-131"></span>Appendix C — Lexicons

This section contains the lexicons used to derive various examples
throughout this work. They can be used to duplicate results, or as a
starting point for expansion of analyses and further investigation.

### <span id="anchor-132"></span>**VISSER’S GENERALIZATION — MOVEMENT THEORY OF CONTROL**

***\{***

*****l******exicon: \[***

***\{***

*****t******ag: "C\_decl", syn: \[***

***"cC\[decl\]",***

***"=T\[\]"\],***

*****s******em: "",***

*****p******hon: ""***

***\},***

***\{***

*****t******ag: "v\_intrans", syn: \[***

***"cv\[intrans\]",***

***"=V\[\]",***

***"=D\[\]\],***

*****s******em: "",***

*****p******hon: ""***

***\},***

***\{***

*****t******ag: "v\_ditrans",***

*****s******yn: \[***

***"cv\[ditrans\]",***

***"=VDitrans\[\]",***

***"=D\[\]"\]***

*****s******em: "",***

*****p******hon: ""***

***\},***

***\{***

*****t******ag: "win", syn: \[***

***"cV\[win\]"\], sem: "",***

*****p******hon: ""***

***\},***

***\{***

*****t******ag: "to-inf", syn: \[***

***"cT\[to\]",***

***"=v\[\]",***

***"=D\[\]"\],***

*****s******em: "",***

*****p******hon: ""***

***\},***

***\{***

*****t******ag: "T\_past", syn: \[***

***\],***

*****s******em: "",***

*****p******hon: ""***

***\},***

***\{***

*****t******ag: "promise", syn: \[***

***"cVDitrans\[promise\]", "=T\[\]",***

***"=PDat\[\]"\],***

*****s******em: "",***

*****p******hon: ""***

***\},***

***\{***

*****t******ag: "to-P", syn: \[***

***"cPDat\[pdat\]",***

***"=D\[\]",***

***"iCase\[dat\]"\], sem: "",***

*****p******hon: ""***

***\},***

***\{***

*****t******ag: "Mary", syn: \[***

***"cD\[mary\]",***

***"uCase\[\]"\], sem: "",***

*****p******hon: ""***

***\},***

***\{***

*****t******ag: "John", syn: \[***

***"cD\[john\]",***

***"uCase\[\]"\], sem: "",***

*****p******hon: ""***

***\},***

***\{***

*****t******ag: "pro-subj", syn: \[***

***"cD\[john\]",***

***"uCase\[\]"\], sem: "",***

*****p******hon: ""***

***\}***

***\]***

***\}***

### <span id="anchor-133"></span>PARROTS LIKE NUTS

***\{***

***"lexicon": \[***

***\{***

***"tag": "nuts", "syn": \[***

***"cN\[nuts\]",***

***"iPhi\[3pl\]"***

***\],***

***"sem": "",***

***"phon": ""***

***\},***

***\{***

***"tag": "parrots", "syn": \[***

***"cN\[parrots\]",***

***"iPhi\[3pl\]"***

***\],***

***"sem": "",***

***"phon": ""***

***\},***

***\{***

***"tag": "like", "syn": \[***

***"cV\[like\]",***

***"=D\[\]"***

***\],***

***"sem": "",***

***"phon": ""***

***\},***

***\{***

***"tag": "v\_trans", "syn": \[***

***"cv\[trans\]",***

***"=V\[\]",***

***"=D\[\]",***

***"iCase\[acc\]"***

***\],***

***"sem": "",***

***"phon": ""***

***\},***

***\{***

***"tag": "T",***

***"syn": \[***

***"cT\[pres\]",***

***"=v\[\]",***

***"=D\[\]",***

***"=uPhi\[\]",***

***"iCase\[nom\]"***

***\],***

***"sem": "",***

***"phon": ""***

***\},***

***\{***

***"tag": "C", "syn": \[***

***"cC\[decl\]",***

***"=T\[\]"***

***\],***

***"sem": "",***

***"phon": ""***

***\},***

***\{***

***"tag": "det", "syn": \[***

***"cD\[det\]",***

***"=N\[\]",***

***"uCase\[\]"***

***\],***

***"sem": "",***

***"phon": ""***

***\}***

***\]***

***\}***

# <span id="anchor-134"></span>Curriculum vitae

Education

December 2016PhD in Linguistics, **Indiana University**, Bloomington

May 1997BA in Philosophy, English Literature

**Appalachian State University**, Boone, NC

Work

**Jan 2013-present**Co-Founder and CTO at **Periodic**, Bloomington, IN

**Sep 2011-Jan 2013**Lead Developer at **ScheduleThing LLC**,
Bloomington, IN

**Jan 2010-May 2010**

Instructor for L310: Syntax **Indiana University**, Bloomington, IN

**Jan  2007-May  2009**Research Assistant **Indiana University**,
Bloomington, IN

**Jan  2004-May  2005**Research Assistant **Indiana University**,
Bloomington, IN

Publications

Markus Dickinson and Joshua Herring (2008). *Developing Online ICALL
Exercises for Russian*. *The 3rd Workshop on Innovative Use of NLP for
Building Educational Applications (ACL08- NLP-Education)*. Columbus, OH.

Markus Dickinson and Joshua Herring (2008). *Russian Morphological
Processing for ICALL*.

*The Fifth Midwest Computational Linguistics Colloquium (MCLC-5)*. East
Lansing, MI.

Damir Cavar, Joshua Herring, Toshikazu Ikuta, Paul Rodrigues, Giancarlo
Schrementi (2006) *On Unsupervised Grammar Induction from Untagged
Corpora*. In: *P. Kaszubski (ed.) PSiCL: Poznań Studies in Contemporary
Linguistics*. 41, Adam Mickiewicz University, Poznań, Poland. pp. 57-71.
ISBN: 73-7208-165-4

Damir Cavar, Joshua Herring, Toshikazu Ikuta, Paul Rodrigues, Giancarlo
Schrementi (2004) *On Statistical Bootstrapping.* In: William G. Sakas
(ed.) *Proceedings of the First Workshop on Psycho-computational Models
of Human Language Acquisition, held in cooperation with COLING 2004*,
Geneva, pp. 9-16. ACL Anthology

Damir Cavar, Joshua Herring, Toshikazu Ikuta, Paul Rodrigues, Giancarlo
Schrementi (2004) *Alignment Based Induction of Morphology Grammar and
its Role for Bootstrapping*. In: Gerhard Jäger, Paola Monachesi, Gerald
Penn and Shuly Wintner (eds.) *Proceedings of Formal Grammar 2004*,
Nancy, pp. 47-62.

1.  It should be noted here that not all minimalist researchers fully
    adopt or are entirely comfortable with phases. See (Epstein and
    Seely 2006) for one skeptical approach.

2.  In minimalist practice there are always two; in principle, any
    number are possible

3.  Some theorists, notably (Chomsky 2008), are loathe to allow any
    operations without a featural motivation and have stipulated *edge
    features*, a special kind of feature that simply allows an item to
    undergo **merge**. Empirical motivation for this is somewhat
    unclear.

4.  Alternately, an item is copied and re-**Merge**d, with an
    independent interface process responsible for **Delete**-ing one of
    the other instance of a duplicated item. See (Nunes 2004) for a
    prominent implementation of such a system.

5.  ***EPP*** is a bit of a problematic category in Minimalism. It is
    essentially a placeholder — a feature that implements the fact that
    some syntactic projections seem to require — or at least allow —
    specifiers for reasons unknown or not fully understood. EPP simply
    requires that the projection have a specifier, often without much in
    the way of discrimination about what types of objects fill it.

6.  Of course, there are other mechanisms (e.g. case-related
    considerations) to either prevent *there* from **Merge**-ing at this
    point in the derivation — or else to prevent it from moving to the
    left periphery if it is **Merge**d here

7.  An in-order traversal of a binary tree starts at the root of a tree
    structure and then recursively orders all elements of the tree by
    ordering elements in the left branch of each node ahead of elements
    in the right. (See (Sedgewick and Wayne 2011) for a more detailed
    explanation.) Though the syntactic literature tries to avoid
    explicit encoding of concepts like left branch and right branch in
    its discussion of hierarchical structures, they can generally be
    mapped onto purely hierarchical relations like C-command. See (Kayne
    1994) for the most influential example of such a mapping process.

8.  It should be noted that there are many proposals for the landing
    site of the object in object shift constructions and that not all of
    them are problematic for **PIC**<sub>1</sub>. Many involve
    adjunction to vP, for example, an analysis which treats the object
    much like the subject — it has adjoined to make itself available to
    syntactic operations beyond the phase that contains its θ-position.
    See (Vikner 2005) for a good survey of analyses of object shift.

9.  Of course, *what* still blocks movement of the subject *parrots* to
    **T**. This issue is typically resolved with appeals to the idea
    that items in the same *phase* periphery are *equidistant* goals for
    the purposes of locality. Some details are given later in the
    chapter.

10. Motivated, presumably, either as a reflex of Case agreement (on the
    assumption that *v *is responsible for **Acc **case assignment), or
    by so-called *agnostic movement *(Franks and Lavine 2006), whereby
    an item that bears unvalued features at the end of a phase may move
    to the edge of the phase as a **Last Resort **to save the derivation
    from crash.

11. This seems to be how (Chomsky 2008) sees it.

12. Though not strictly required. As can be seen in the more detailed
    derivations in the appendices, implementors are free to include only
    a single lexical array in their derivation classes if they like.
    However, this frequently yields muddled results. The claim that
    *phases *are not a system primitive is based on part on the fact
    that use of grouped subarrays is not required.

13. Definitions are taken from (Narita 2011) but conform well to the
    principles as originally formulated in the foundational works
    (Chomsky 1993) and (Chomsky 1995)

14. E.g. *\*John think she’s stupid — *at least in standard varieties of
    English the **3rd **person marker is required when the subject is
    singular.

15. There was always a tension in early Minimalism between the
    proscription by the **No-Tampering Condition **on altering the form
    of participating items in a derivation and the founding idea that
    Syntax was motivated by the need to remove any material that is
    present in the Lexicon but illegible at one or both of the
    interfaces.

16. Or at least up to (Stabler 2011). The most recent, and explicit,
    variant in (Collins and Stabler 2016) does not expressly give a
    formalization of a linguistic feature system, but it is compatible
    with the system used in earlier works in this tradition, a fact
    mentioned in the paper.

17. This program of rigorously formalizing core ideas and mechanisms
    common to most research in the Minimalist Program refers to grammars
    written using its objects as Minimalist Grammars (MGs).

18. Given the commitment to the universality hypothesis (see (Baker
    2003) and (Lightfoot 1979) for discussion) underpinning parametric
    approaches to language variation, there was never a suggestion that
    the object might raise to this position in French but not in English
    — the question was one of *when*.

19. As of (Chomsky 1986b), which introduced the **Last Resort
    **principle to UG — a ban on operations which are not directly
    motivated — it was not enough to stipulate it.

20. The period between (Chomsky 1991) and (Chomsky 1995) when Minimalist
    principles were proposed and generally agreed upon, but there was
    not yet any explicit program or bevy of officially- sanctioned
    linguistic mechanisms which researchers were expected to strive to
    reduce their analyses to.

21. If the subject agrees with the verb only then when Tense is finite,
    as seems to be the case, then whatever *Agr *head mediates the
    agreement has to already “know” the verb is tensed, which in
    technical terms means the *Agr *head selects *T *rather than the
    other way around. If **Select **is always **Head**-**Spec**, then it
    follows that the *Agr *head would need to dominate *TP *in the
    hierarchy.

22. From (Boeckx 2008b).

23. From (Boeckx 2008b).

24. It has of course been argued that morphology does not drive syntax
    at all — perhaps most explicitly in (Bobaljik 2002), where agreement
    marking is taken to be a superficial PF phenomenon. If that is so,
    then morphological agreement marking is not necessarily evidence of
    a long-distance ***syntactic ***dependency between items. However,
    this should not be taken further than it goes. Rejecting morphology
    as a driver of syntax does not obviate the need for items to
    identify — and license the presence of — other items at a remove,
    ***based ****on ****features ****of the ****involved ****items***.
    The present system need not take a position on how deep these
    processes go; it fulfills its purpose in supplying researchers who
    believe that morphological agreement drives syntax with the tools to
    model their systems.

25. Not, of course, by everyone — the subject remains mildly
    controversial. Perhaps the most prominent attempt to maintain
    move-based analyses of agreement is (Chandra 2007)

26. Foundational works date back to the 1970s, with (Rizzi 1978) and
    (Aissen and Perlmutter 1976) being prominent.

27. See the original reference for a the full facts, but the gist is
    that in Aleut morphological marking on a subject argument can
    reflect when another (non-subject) argument is unrealized.

28. The idea that these are separate Probes suggests that in the case
    where a 3pl argument is higher than, say, a 1sg argument, the
    agreement morphology on the verb should be 1pl rather than 1sg, but
    Preminger does not address this question directly.

29. *Misleading *because the brain does more than process language and
    uses the same neural- computational operations to implement every
    domain of knowledge it covers. Learning about language processing by
    studying neurons is like learning about spreadsheets by studying
    microchips: it’s not that the knowledge is irrelevant so much as
    that it is at the wrong level of abstraction.

30. “**A**pplication **P**rogramming **I**nterface.” An API is a
    collection of subroutine definitions and use protocols that
    “exposes” the functionality of one program for use by an outside
    user (which might itself be another program). The “outside user”
    anticipated in this case is, of course, a syntax researcher working
    in the Minimalist tradition who wants to (a) verify that his theory
    derives all and only what he claims, (b) expose any unintended
    consequences his ideas may have introduced for the theories of
    others and (c) explore the consequences of (seemingly) minor changes
    in his theory — i.e. what structures would be had some choices been
    made differently.

31. EPP features form an obvious exception to this, as they are
    (apparently) unipolar. As will be seen shortly, however, it is
    possible to bring them under the standard bivalent paradigm, and
    this project will do so.

32. To indicate ***i***nterpretable or ***u***ninterpretable, legacy
    terms from the early days of Minimalism

33. One may well wonder why not just leave the value unspecified on the
    “barrier feature.” That is certainly also an option. The trouble
    is that in some systems — especially multiple agree systems (Hiraiwa
    2005) — one may wish to draw a distinction between valued and
    unvalued **Goal**s.

34. *Uniquely identifies *with respect to other items in the lexicon.
    This is not the same as an *index *(or memory address), which
    uniquely identifies a *token *of the item participating in a
    derivation.

35. *Distinct *from the user’s point of view. The system keeps track of
    them by their address in memory — i.e. this is a *multiattachment
    *system by default.

36. The individual feature representations here owe a great deal to
    (Stabler 1997) and subsequent work in the *Minimalist Grammars
    *tradition. Though they are more articulated than Stabler features
    in ways detailed previously, the choice of = to mark a selectional
    feature is, for example, borrowed from the work of Stabler and
    colleagues.

37. This is not a destructive operation. The constituent syntactic
    objects from which the new one is formed are contained within —
    implementationally as pointers, so in computational terms they are
    *referenced by *— the created object and are still available to the
    system for further operations.

38. Workspaces in (Nunes 2004) are theoretical constructs that allow for
    the possibility of parallel sub-derivations, which in turn allows
    for the possibility that items from one sub-derivation can
    participate in another in ways that would otherwise be
    countercyclic. There is not space to go into the complexities of
    this proposal here; suffice it to say that although Workspaces in
    this system do not directly model the Workspaces of (Nunes 2004),
    Nunes-style system coulbe implmented using them by expanding Stages
    to host multiple Workspaces (and multiple LexicalArrays).

39. Active does not mean anything particularly special — the “active”
    item is simply the one the system will operate on next, allowing it
    to *select *and *probe *to find matches for its own active
    *feature*s, possibly *merge*ing with other items as a side-effect.

40. In systems that employ phases — at least as described by (Chomsky
    2001) — this will be the *lexical subarray *associated with that
    phase rather than the full lexical array that triggered the
    derivation.

41. As in this system *phase *heads are the only locus of
    uninterpretable features, and failure to find a match in one’s own
    domain means there will never be one.

42. This does not delete the item. Implementationally, these are
    pointers, so removing it from the array effectively “returns” it to
    its position lower in the hierarchy, in the case where it was found
    in the active syntactic object’s **Comp**.

43. One could also think of this the other way — that EPP is not itself
    a feature but rather a class of features (or perhaps a diacritic on
    a feature) that interrupts long-distance agree in favor of merge.
    Seen this way, it is the fact of language which is responsible for
    selection of items from the **lexical array **and into the
    derivation in the first place. This idea would have to be explored,
    but it holds the promise of making the EPP somewhat less mysterious.
    The question of ***why**** ***there is an EPP is answered — it just
    ***is**** ***select — and the central question about the EPP would
    be rephrased as “why does select happen in these cases where it is
    not strictly necessary?” It would effectively set the traditional
    way of looking at EPP on its head.

44. Computational note: although pointers are used in many parts of the
    implementation, stages are “purely functional data structures” in
    the sense of (Okasaki 1999) — that is, any changes to their state
    are implemented by copying the stage. This serves two purposes, one
    future and one present. The present purpose is that it memoizes the
    derivation, keeping a full record in memory for treatment by the
    interfaces, and also the user display output systems. The future
    purpose is that it makes for easy introduction of first-class
    *continuations* — in the sense of (Strachey and Wadsworth 1972) —
    into the process. There is no actual evidence that these are useful
    yet for natural language syntax, the author is simply indulging a
    hunch that they will prove so.

45. Head movement was never allowed to skip heads; it was always
    strictly local (Travis 1984).

46. At least, not at the same level of the hierarchy. Since this system
    allowed feature geometry and computes “value” through unification,
    it is possible to be revalued at a different value IFF the new value
    is subsumed by the original value in the specified feature geometry.
    But that does not apply to any known *θ *systems, in which values
    are always mutually exclusive.

47. Like the **cleanup **operation of the previous section.

48. In no *phase *system that the author is aware of is **Select
    **limited to phase heads — nor is there any real reason to believe
    it would be all that problematic for it to be.

49. At least, this is true on the assumptions that positions can’t be
    doubly-filled and that movement leaves behind a *trace *that
    continues to hold a position that was lexically occupied at an
    earlier stage in the derivation.

50. *\*John*<sub>i </sub>*loved t*<sub>i </sub>cannot mean “John loved
    himself” — and the requirement that each *θ*-position have a
    distinct argument prevents the derivation that would allow it.

51. All examples in this section are from (Boeckx, Hornstein, and Nunes
    2010).

52. At least, this is the claim in (Landau 2003). Some speakers do not
    immediately share this intuition.

53. Or, in the jargon of the field, between explanatory and descriptive
    adequacy.

54. “Better” in the sense that they go somewhat further beyond simply
    describing the *immediate *environment in which PRO “appears” by
    tying control to the degree of tense dependency of the lower clause
    on the matrix.

55. In the original, the passive morpheme itself was taken to be such an
    argument. Such an analysis would plausibly not block raising to
    subject (by the object) as the *-en *morpheme is presumably not a D
    category and is a head in any case. This solution isn’t really
    available to a minimalist researcher in good faith, however, since
    it would require explanation for why everwhere else in the grammar
    reference is a property of D and only in this one place of a verbal
    morpheme.

56. *To Mary was promised a rose garden *is not strictly ungrammatical,
    of course — perhaps a bit stilted — but it is focused in a way that
    the reference sentence is not.

57. Of course, one can always avail oneself of PF interface solutions to
    these problems. It could be argued that *to *resurfaces in
    pronunciation, desipte having been syntactically incorporated, only
    in those cases where its object remains *in situ*.

58. In actual implementation, merely the *pointer *to this object is
    copied.

59. Though it’s a bit difficult to defend when one stops to *really
    *think through head movement.

60. By trying to treat the indirect object as the canonical object in
    passivization, in this case — the canonical object being what is
    promised, not the person it’s promised to.

61. Put differently, it is when effects extend beyond the individual
    phrase — in attempting to raise *pro *to subject — that things go
    awry.

62. which is not “frozen” in the standard sense as it is not
    ***case***-valued

63. at least on the phrasal level, because it effectively bans the same
    item holding more than one *θ*-role

64. In this sense, as Landau freely admits, the theory more or less
    recreates the null case approach to PRO.

65. A special kind of feature that encodes a long-distance dependency.
    See (Pollard and Sag 1994) for explication.

66. Possibly as defined by a reference corpus.

67. In fact, it is not unknown for Minimalist theories to leverage this
    distinction. See (Brannigan 2010) for what is arguably an example.

[Back](jherring-6)
